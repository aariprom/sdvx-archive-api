generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ========= Enums =========
 */

enum DifficultyStd {
  NOV
  ADV
  EXH
  MXM
  INF
  GRV
  HVN
  VVD
  XCD
  ULT
  ETC
}

enum GradeStd {
  S
  AAAP
  AAA
  AAP
  AA
  AP
  A
  B
  C
  D
  ETC
}

enum ClearTypeStd {
  PUC
  UC
  MAX
  EXC
  EFF
  COMP
  CRASH
  ETC
}

enum SourceType {
  MANUAL
  CSV
  API
  ETC
}

enum ImportStatus {
  PENDING
  DONE
  FAILED
}

/**
 * ========= Auth =========
 */

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  playerName   String
  passwordHash String
  settings     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // relations
  plays      Play[]
  importJobs ImportJob[]
  tokens     RefreshToken[]

  @@index([createdAt])
}

model RefreshToken {
  id        String    @id @default(cuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  // 해시 저장 (원문 저장 금지)
  tokenHash String    @unique
  userAgent String?
  ip        String?
  createdAt DateTime  @default(now())
  expiresAt DateTime
  revokedAt DateTime?

  @@index([userId, createdAt])
  @@index([expiresAt])
}

/**
 * ========= SDVX Data =========
 */

model Track {
  id        String   @id @default(cuid())
  name      String
  artist    String?
  effecter  String?
  // false if it is deleted or unavailable
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  charts    Chart[]

  @@index([name])
}

model Chart {
  id      String @id @default(cuid())
  trackId String

  // data
  // prevent the deleteion of Track if related Chart exists
  track           Track         @relation(fields: [trackId], references: [id], onDelete: Restrict)
  difficultyLabel DifficultyStd
  level           Int
  noteCount       Int?
  bpmMin          Int?
  bpmMax          Int?
  jacketUrl       String?
  // date of the chart updated on SDVX
  versionAt       String

  // relations
  play Play[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([trackId, difficultyLabel, level])
  @@index([trackId, level])
  @@index([trackId, difficultyLabel, level])
}

/**
 * ========= Play & Source =========
 */

model Source {
  id        String     @id @default(cuid())
  type      SourceType
  label     String?
  meta      Json?
  createdAt DateTime   @default(now())

  plays Play[]
}

model Play {
  id       String   @id @default(cuid())
  userId   String
  chartId  String
  sourceId String
  playedAt DateTime

  // relations
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  chart  Chart  @relation(fields: [chartId], references: [id], onDelete: Restrict)
  source Source @relation(fields: [sourceId], references: [id], onDelete: NoAction)

  // data
  // some fields maybe only available when manual/csv
  score        Int
  gradeStd     GradeStd?
  clearTypeStd ClearTypeStd?
  gaugeValue   Decimal?      @db.Decimal(3, 1)
  crit         Int?
  near         Int?
  error        Int?
  maxChain     Int?
  volforce     Decimal?      @db.Decimal(5, 3) // amount of volforce that this play worth
  memo         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, chartId, sourceId, playedAt])
  @@index([userId, playedAt])
  @@index([chartId, score])
  @@index([userId, chartId, playedAt])
}

/**
 * ========= Import Log =========
 */

model ImportJob {
  id     String       @id @default(cuid())
  userId String
  user   User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  status ImportStatus @default(PENDING)

  fileName String
  fileUrl  String

  createdAt  DateTime  @default(now())
  finishedAt DateTime?
  summary    Json?
}
